[TOC]

# **Redis常见问题汇总**

**Redis优点**

```python
1、读写速度快. 数据存放在内存中
2、支持数据类型丰富,string,hash,list,set,sorted
3、支持事务
4、可以用于缓存,消息队列,按key设置过期时间,到期后自动删除
5、支持数据持久化(将内存数据持久化到磁盘),支持AOF和RDB两种持久化方式,从而进行数据恢复操作,可以有效地防止数据丢失
5、支持主从(master-slave)复制来实现数据备份,主机会自动将数据同步到从机
```

**来介绍一下redis中的数据类型**

| 类型       | 特点                                                         | 使用场景                                                     |
| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| string     | 简单key-value类型，value可为字符串和数字                     | ==常规计数==（微博数, 粉丝数等功能）                         |
| hash       | 是一个string类型的field和value的映射表，hash特别适合用于存储对象 | ==存储部分可能需要变更的数据==（比如用户信息）               |
| list       | 有序可重复列表                                               | ==关注列表，粉丝列表，消息队列等==                           |
| set        | 无序不可重复列表                                             | ==存储并计算关系==（如微博，关注人或粉丝存放在集合，可通过交集、并集、差集等操作实现如共同关注、共同喜好等功能） |
| sorted set | 每个元素带有分值的集合                                       | ==各种排行榜==                                               |

**redis中的持久化方案**

```python
# RDB
快照形式，定期把内存中的数据保存到磁盘。Redis默认支持的持久化方案。速度快但是服务器断电的时候会丢失部分数据

# AOF
把所有对redis数据库增删改操作的命令保存到文件中。数据库恢复时把所有的命令执行一遍即可。

'两种持久化方案同时开启使用,系统优先使用AOF文件来恢复数据库.能保证数据的完整性,但是速度慢。
```

**使用过Redis分布式锁么，它是什么回事？**

```python
从redis2.8版本开始，set命令集成了两个参数，nx和ex，先拿nx来争抢锁，抢到之后，再用ex参数给锁加一个过期时间防止锁忘记了释放，造成死锁
```

## **缓存穿透**

```python
# 原理
1.缓存和数据库都没有的数据，而用户反复发起请求。 			'如 假的用户ID
2.指查询一个数据库一定不存在的数据。
3.正常的使用缓存流程大致是，数据查询先进行Redis缓存查询，如果key不存在或者key已经过期，再对数据库进行查     询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。如过客户端偶尔的查询不存在的数据，   对后端数据库影响较小，如果客户端反复发起请求，对数据库的冲击消耗是很大的。

# 场景
比如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大

# 解决方案：
   1、请求校验，接口层增加校验，如对id做基础校验，id<=0的直接拦截
   2、都无法取到数据时也可以将key-value对写为key-null，缓存有效时间比如30秒左右，这样可以防止攻击用户反复用同一个id暴力攻击
```

## **缓存击穿** 

```python
# 原理
1.缓存没有，数据库有，一般是缓存时间到期， 顺势并发太大
2.缓存击穿，是指经常访问的key，大并发量经常对这些key进行访问，当这些key在(到了过期时间)失效的瞬间，持续的   大并发量就穿破缓存，直接请求数据库，产生缓存中没有数据，直接穿透缓存访问数据库。

#解决方案
1、热点数据不过期  
2、上锁: 重新设计缓存的使用方式，当我们通过key去查询数据时，首先查询缓存，如果没有，就通过分布式锁进行加锁，取得锁的进程查DB并设置缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回缓存数据或者再次查询DB
```

## **缓存雪崩**

```python
# 原理
1.(内存)缓存中大批量数据过期失效(设定的时间到期),导致大批量请求转向数据库发起请求。
2.缓存中大批量数据过期失效(设定的时间到期)，导致瞬时大批量不同请求在缓存中查找不到数据后，大批量的请求转向数据库发起请求，导致数据库压力骤增。

# 解决方案
解决方案
1、缓存设置随机时间（避免缓存设置相近的有效期；为有效期增加随机值）
2、热点数据不过期
```

```python
'示 例：
做电商项目的时候，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。
```



